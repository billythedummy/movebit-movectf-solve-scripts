# move_lock

This challenge involves recovering an encryption key and plaintext message from a set of known plaintexts and corresponding ciphers. 

## Writeup (twitter)

This challenge isn’t quite a smart contract exploit but a fun codebreaking exercise.

Lets look at the contract code. There’s an encrypted_flag const in the code, and your job is to figure out the 2 inputs to the encryption function, movectf_lock(), to recover the flag.

Reading the code, the cipher is generated in blocks of 3 chars. The first data serves as the plaintext input. It’s padded with a constant byte string [4, 15, 11, 0, 13, 4, 19, 19, 19], at the front, and zero-padded to a length divisible by 3 at the back.

The second input to the function serves as the encryption key, and is 9 numbers acting as a 3x3 matrix. The encryption algorithm is ciphertext block = matmul(key, plaintext block) % 26 for each 3-char block of the padded plaintext.

I spent way too long unsuccessfully trying to recall modulo math (which didn’t turn out to be that useful to my approach in the end).

Finally, at some point I began thinking: wait a sec, is this just a cheese? Can I just pass in the identity matrix as the key and the ciphertext and the input lmao

Quickly realized that I can’t because there was a constant prefix padding which clearly wasn’t an identity mapping. For instance, the first block of the constant prefix padding (4, 15, 11) mapped to (19, 16, 17) ciphertext

Wait, but that means I’m given 3 blocks of plaintexts and their corresponding ciphertexts. I can probably recover the key from this.

Each char in the ciphertext block is generated independently by the corresponding row in the key, and the plaintext block. For example, the first cipher 19 is generated by the first row of the key and the plaintext block. I can probably recover each row of the key independently.

For each row, we’re given 3 blocks. 3 simultaneous equations. Lets rearrange them into the following matrix. Let C = the 9 char constant plaintext prefix padding arranged in a 3x3 matrix.

Let o = the corresponding ciphertext output. For, recovering the first row, that’s the numbers at index [0], [3], [6].

We need to find vector row such that matmul(C, row) = o.

In retrospect, I could’ve just used the inverse of C to do row = matmul(inv(C), o) but I wasn’t sure  how matrix inverse worked with modular arithmetic so I brute forced it instead. I wrote a simple python function that advanced through the permutations of a base-26 array.

And then just loop and check until you find the correct row.

Once we had the key matrix, it was a similar procedure to decrypt the rest of the ciphertext. Again, realized later that I could’ve just done plainblock = matmul(inv(key), cipherblock), but I brute-forced here again.

And we’ve got our flag.

Curious what the plaintext message was beyond the array of numbers? Notice that the english alphabet is base-26 too. Let’s see what this gives us.

“congratulations you managed to break the hill cipher hack the hacky planet”.

I see. Looks like I would’ve solved this challenge a lot faster if I had paid attention in cryptography class. Ah well. https://en.wikipedia.org/wiki/Hill_cipher. 
