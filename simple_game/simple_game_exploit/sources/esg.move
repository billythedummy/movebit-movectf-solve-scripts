module esg::e {
    use std::hash;
    use std::vector;
    use sui::bcs;
    use sui::tx_context::TxContext;

    use ctf::adventure::{slay_boar, slay_boar_king};
    use ctf::hero::{Self, Hero};
    use ctf::inventory::{get_flag, TreasuryBox};

    /// get flag, aborting if rng
    /// doesnt give us the flag
    public entry fun gf(tb: TreasuryBox, ctx: &mut TxContext) {
        let rng = preview_rand_u64_range(0, 100, 0, ctx);
        if (rng != 0) {
            abort 69
        } else {
            get_flag(tb, ctx)
        }
    }

    /// slay boar king, aborting if rng
    /// doesnt drop a TreasuryBox
    public entry fun sbk(hero: &mut Hero, ctx: &mut TxContext) {
        assert!(winnable(180, 220, 20, 25, 10, 15, hero, ctx), 96);
        let rng = preview_rand_u64_range(0, 100, 4, ctx);
        if (rng != 0) {
            abort 69
        } else {
            slay_boar_king(hero, ctx)
        }
    }

    /// slay boar, aborting if rng
    /// doesnt drop an armor or sword
    public entry fun f(hero: &mut Hero, ctx: &mut TxContext) {
        let rng = preview_rand_u64_range(0, 100, 4, ctx);
        if (rng > 20) {
            abort 69
        } else {
            slay_boar(hero, ctx)
        }
    }

    /// slay boar, aborting if rng isnt in our favour
    public entry fun noob(hero: &mut Hero, ctx: &mut TxContext) {
        assert!(winnable(80, 120, 5, 15, 4, 6, hero, ctx), 96);
        slay_boar(hero, ctx)
    }

    fun winnable(
        hp_start: u64,
        hp_end: u64,
        strength_start: u64,
        strength_end: u64,
        defense_start: u64,
        defense_end: u64,
        h: &Hero,
        ctx: &mut TxContext
    ): bool {
        // 0th is create monster's id
        let monst_hp = preview_rand_u64_range(hp_start, hp_end, 1, ctx);
        let monst_str = preview_rand_u64_range(strength_start, strength_end, 2, ctx);
        let monst_def = preview_rand_u64_range(defense_start, defense_end, 3, ctx);
        let str = hero::strength(h);
        let def = hero::defense(h);
        if (monst_def > str) {
            return false
        };
        let dps = str - monst_def;
        let dmg = monst_str - def;
        let turns = monst_hp / dps + if (monst_hp % dps == 0) {
            0
        } else {
            1
        };
        turns * dmg < hero::hp(h)
    }

    fun preview_rand_u64_range(low: u64, high: u64, ids_created: u64, ctx: &mut TxContext): u64 {
        let ctx_bytes = fake_ctx_bytes(ids_created, ctx);

        let ctx_bytes_2: vector<u8> = bcs::to_bytes(ctx);
        let txh = tx_hash(ctx_bytes_2);
        let uid_bytes = uid(txh, ids_created);

        let info: vector<u8> = vector::empty<u8>();
        vector::append<u8>(&mut info, ctx_bytes);
        vector::append<u8>(&mut info, uid_bytes);

        let seed: vector<u8> = hash::sha3_256(info);
        let value = bytes_to_u64(seed);
        (value % (high - low)) + low
    }

    fun bytes_to_u64(bytes: vector<u8>): u64 {
        let value = 0u64;
        let i = 0u64;
        while (i < 8) {
            value = value | ((*vector::borrow(&bytes, i) as u64) << ((8 * (7 - i)) as u8));
            i = i + 1;
        };
        return value
    }

    fun fake_ctx_bytes(ids_created: u64, ctx: &TxContext): vector<u8> {
        let bytes: vector<u8> = bcs::to_bytes(ctx);
        *vector::borrow_mut(&mut bytes, 61) = (ids_created as u8);
        bytes
    }

    fun tx_hash(ctx_bytes: vector<u8>): vector<u8> {
        let tx_hash = vector::empty<u8>();
        let i = 0;
        while (i < 16) {
            vector::pop_back(&mut ctx_bytes);
            i = i + 1;
        };
        // i just wanted to do a vector slice here but
        // i couldnt find the relevant docs
        // so i just did this weird pop_back into push_back
        // twice thing lol
        let i = 0;
        let intermediate: vector<u8> = vector::empty<u8>();
        while (i < 32) {
            let b = vector::pop_back(&mut ctx_bytes);
            vector::push_back(&mut intermediate, b);
            i = i + 1;
        };
        let i = 0;
        while (i < 32) {
            let b = vector::pop_back(&mut intermediate);
            vector::push_back(&mut tx_hash, b);
            i = i + 1;
        };
        tx_hash
    }

    /// derive_id()
    /// only works if ids_created < 256, which is fine for our case
    fun uid(tx_hash: vector<u8>, ids_created: u64): vector<u8> {
        vector::append(&mut tx_hash, vector[(ids_created as u8), 0, 0, 0, 0, 0, 0, 0]);
        let res = hash::sha3_256(tx_hash);
        let i = 0;
        while (i < 12) {
            vector::pop_back(&mut res);
            i = i + 1;
        };
        res
    }
    
    #[test]
    /// check tx_hash() + uid() implementation
    public fun test() {
        use sui::bcs;
        use sui::object::Self;
        use sui::tx_context::Self;
        use std::debug;

        let ctx = tx_context::dummy();

        let bytes: vector<u8> = bcs::to_bytes(&ctx);
        let tx_hash = tx_hash(bytes);
        let fake_uid = uid(tx_hash, 0);
        debug::print(&fake_uid);
        let uid = object::new(&mut ctx);
        debug::print(&object::uid_to_bytes(&uid));
        object::delete(uid);

        let tx_hash = tx_hash(bytes);
        let fake_uid = uid(tx_hash, 1);
        debug::print(&fake_uid);
        let uid = object::new(&mut ctx);
        debug::print(&object::uid_to_bytes(&uid));
        object::delete(uid);
    }

    #[test]
    /// check preview_rand_u64_range() implementation
    public fun test2() {
        use ctf::random::rand_u64_range;
        use sui::tx_context::Self;
        use std::debug;

        let ctx = tx_context::dummy();

        let a = preview_rand_u64_range(0, 100, 0, &mut ctx);
        let b = rand_u64_range(0, 100, &mut ctx);
        debug::print(&a);
        debug::print(&b);

        let a = preview_rand_u64_range(0, 100, 1, &mut ctx);
        let b = rand_u64_range(0, 100, &mut ctx);
        debug::print(&a);
        debug::print(&b);
    }
}